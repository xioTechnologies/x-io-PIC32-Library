/**
 * @file I2C4.c
 * @author Seb Madgwick
 * @brief I2C driver for PIC32.
 */

//------------------------------------------------------------------------------
// Includes

#include "definitions.h"
#include "I2C4.h"
#include <stddef.h>
#include "Timer/Timer.h"

//------------------------------------------------------------------------------
// Function declarations

static void WaitForInterruptOrTimeout(void);

//------------------------------------------------------------------------------
// Variables

static I2CMessage* currentMessage;
static uint64_t messageTimeout;

//------------------------------------------------------------------------------
// Functions

/**
 * @brief Initialises the module.
 * @param clockFrequency Clock frequency.
 */
void I2C4Initialise(const I2CClockFrequency clockFrequency) {

    // Ensure default register states
    I2C4Deinitialise();

    // Configure I2C
    I2C4BRG = I2CCalculateI2Cxbrg(clockFrequency);
    if (clockFrequency != I2CClockFrequency400kHz) {
        I2C4CONbits.DISSLW = 1; // Slew rate control disabled
    }
    I2C4CONbits.I2CEN = 1; // Enables the I2C module and configures the SDA and SCL pins as serial port pins
}

/**
 * @brief Disable the module.
 */
void I2C4Deinitialise(void) {

    // Disable I2C and restore default register states
    I2C4CON = 0;
    I2C4STAT = 0;

    // Disable interrupt
    EVIC_SourceDisable(INT_SOURCE_I2C4_MASTER);
    EVIC_SourceStatusClear(INT_SOURCE_I2C4_MASTER);
}

/**
 * @brief Generates a start event.
 */
void I2C4Start(void) {
    EVIC_SourceStatusClear(INT_SOURCE_I2C4_MASTER);
    I2C4CONbits.SEN = 1;
    WaitForInterruptOrTimeout();
}

/**
 * @brief Generates a repeated start event.
 */
void I2C4RepeatedStart(void) {
    EVIC_SourceStatusClear(INT_SOURCE_I2C4_MASTER);
    I2C4CONbits.RSEN = 1;
    WaitForInterruptOrTimeout();
}

/**
 * @brief Generates a stop event.
 */
void I2C4Stop(void) {
    EVIC_SourceStatusClear(INT_SOURCE_I2C4_MASTER);
    I2C4CONbits.PEN = 1;
    WaitForInterruptOrTimeout();
}

/**
 * @brief Sends a byte and checks for ACK.
 * @param byte Byte.
 * @return True if an ACK was generated.
 */
bool I2C4Send(const uint8_t byte) {
    EVIC_SourceStatusClear(INT_SOURCE_I2C4_MASTER);
    I2C4STATbits.ACKSTAT = 0;
    I2C4TRN = byte;
    WaitForInterruptOrTimeout();
    return I2C4STATbits.ACKSTAT == 0;
}

/**
 * @brief Receives a byte and generates an ACK or NACK.
 * @param ack True for ACK.
 * @return Byte.
 */
uint8_t I2C4Receive(const bool ack) {

    // Receive
    EVIC_SourceStatusClear(INT_SOURCE_I2C4_MASTER);
    I2C4CONbits.RCEN = 1;
    WaitForInterruptOrTimeout();

    // ACK/NACK
    EVIC_SourceStatusClear(INT_SOURCE_I2C4_MASTER);
    I2C4CONbits.ACKDT = ack ? 0 : 1;
    I2C4CONbits.ACKEN = 1;
    WaitForInterruptOrTimeout();
    return I2C4RCV;
}

/**
 * @brief Waits for the interrupt or timeout.
 */
static void WaitForInterruptOrTimeout(void) {
    const uint64_t timeout = TimerGetTicks64() + (TIMER_TICKS_PER_SECOND / (I2CClockFrequency100kHz / 10)); // 10 clock cycles timeout for slowest clock
    while (true) {
        if (EVIC_SourceStatusGet(INT_SOURCE_I2C4_MASTER)) {
            break;
        }
        if (TimerGetTicks64() > timeout) {
            break;
        }
    }
}

/**
 * @brief Begins message.
 * @param message Message.
 */
void I2C4BeginMessage(I2CMessage * const message) {

    // Do nothing if message in progress
    if (I2C4MessageInProgress()) {
        return;
    }

    // Set current message
    currentMessage = message;
    message->index = 0;

    // Calculate message timeout
    messageTimeout = TimerGetTicks64() + (I2C_MESSAGE_MAX_LENGTH * I2C_TIMEOUT);

    // Trigger first interrupt
    EVIC_SourceStatusSet(INT_SOURCE_I2C4_MASTER);
    EVIC_SourceEnable(INT_SOURCE_I2C4_MASTER);
}

/**
 * @brief Returns true if the message is in progress.
 * @return True if the message is in progress.
 */
bool I2C4MessageInProgress(void) {
    if (TimerGetTicks64() >= messageTimeout) {
        EVIC_SourceDisable(INT_SOURCE_I2C4_MASTER);
    }
    return EVIC_SourceIsEnabled(INT_SOURCE_I2C4_MASTER);
}

/**
 * @brief I2C interrupt handler. This function should be called by the ISR
 * implementation generated by MPLAB Harmony.
 */
void I2C4InterruptHandler(void) {
    EVIC_SourceStatusClear(INT_SOURCE_I2C4_MASTER); // clear interrupt flag first because next event may complete before ISR returns
    const int index = currentMessage->index++;
    switch (currentMessage->event[index]) {
        case I2CMessageEventStart:
            I2C4CONbits.SEN = 1;
            break;
        case I2CMessageEventRepeatedStart:
            I2C4CONbits.RSEN = 1;
            break;
        case I2CMessageEventStop:
            I2C4CONbits.PEN = 1;
            break;
        case I2CMessageEventSend:
            I2C4TRN = currentMessage->data[index];
            break;
        case I2CMessageEventReceive:
            I2C4CONbits.RCEN = 1;
            break;
        case I2CMessageEventAck:
            *currentMessage->destination[index] = I2C4RCV;
            I2C4CONbits.ACKDT = 0;
            I2C4CONbits.ACKEN = 1;
            break;
        case I2CMessageEventNack:
            *currentMessage->destination[index] = I2C4RCV;
            I2C4CONbits.ACKDT = 1;
            I2C4CONbits.ACKEN = 1;
            break;
        case I2CMessageEventEnd:
            EVIC_SourceDisable(INT_SOURCE_I2C4_MASTER);
            if (currentMessage->complete != NULL) {
                currentMessage->complete();
            }
            break;
    }
}

//------------------------------------------------------------------------------
// End of file
