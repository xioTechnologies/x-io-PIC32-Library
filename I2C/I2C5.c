/**
 * @file I2C5.c
 * @author Seb Madgwick
 * @brief I2C driver for PIC32 devices.
 */

//------------------------------------------------------------------------------
// Includes

#include "definitions.h"
#include "I2C5.h"
#include <stddef.h>
#include "Timer/Timer.h"

//------------------------------------------------------------------------------
// Function declarations

static void WaitForInterruptOrTimeout(void);

//------------------------------------------------------------------------------
// Variables

static I2CMessage* message;
static uint64_t timeout;

//------------------------------------------------------------------------------
// Functions

/**
 * @brief Initialises the module.
 * @param clockFrequency Clock frequency.
 */
void I2C5Initialise(const I2CClockFrequency clockFrequency) {

    // Ensure default register states
    I2C5Deinitialise();

    // Configure I2C
    I2C5BRG = I2CCalculateI2Cxbrg(clockFrequency);
    if (clockFrequency != I2CClockFrequency400kHz) {
        I2C5CONbits.DISSLW = 1; // Slew rate control disabled
    }
    I2C5CONbits.I2CEN = 1;
}

/**
 * @brief Disable the module.
 */
void I2C5Deinitialise(void) {

    // Disable I2C and restore default register states
    I2C5CON = 0;
    I2C5STAT = 0;

    // Disable interrupt
    EVIC_SourceDisable(INT_SOURCE_I2C5_MASTER);
    EVIC_SourceStatusClear(INT_SOURCE_I2C5_MASTER);
}

/**
 * @brief Generates a start event.
 */
void I2C5Start(void) {
    EVIC_SourceStatusClear(INT_SOURCE_I2C5_MASTER);
    I2C5CONbits.SEN = 1;
    WaitForInterruptOrTimeout();
}

/**
 * @brief Generates a repeated start event.
 */
void I2C5RepeatedStart(void) {
    EVIC_SourceStatusClear(INT_SOURCE_I2C5_MASTER);
    I2C5CONbits.RSEN = 1;
    WaitForInterruptOrTimeout();
}

/**
 * @brief Generates a stop event.
 */
void I2C5Stop(void) {
    EVIC_SourceStatusClear(INT_SOURCE_I2C5_MASTER);
    I2C5CONbits.PEN = 1;
    WaitForInterruptOrTimeout();
}

/**
 * @brief Sends a byte and checks for ACK.
 * @param byte Byte.
 * @return True if an ACK was generated.
 */
bool I2C5Send(const uint8_t byte) {
    EVIC_SourceStatusClear(INT_SOURCE_I2C5_MASTER);
    I2C5STATbits.ACKSTAT = 0;
    I2C5TRN = byte;
    WaitForInterruptOrTimeout();
    return I2C5STATbits.ACKSTAT == 0;
}

/**
 * @brief Receives a byte and generates an ACK or NACK.
 * @param ack True for ACK.
 * @return Byte.
 */
uint8_t I2C5Receive(const bool ack) {

    // Receive
    EVIC_SourceStatusClear(INT_SOURCE_I2C5_MASTER);
    I2C5CONbits.RCEN = 1;
    WaitForInterruptOrTimeout();

    // ACK/NACK
    EVIC_SourceStatusClear(INT_SOURCE_I2C5_MASTER);
    I2C5CONbits.ACKDT = ack ? 0 : 1;
    I2C5CONbits.ACKEN = 1;
    WaitForInterruptOrTimeout();
    return I2C5RCV;
}

/**
 * @brief Waits for the interrupt or timeout.
 */
static void WaitForInterruptOrTimeout(void) {
    const uint64_t timeout = TimerGetTicks64() + (TIMER_TICKS_PER_SECOND / (I2CClockFrequency100kHz / 10)); // 10 clock cycles timeout for slowest clock
    while (true) {
        if (EVIC_SourceStatusGet(INT_SOURCE_I2C5_MASTER)) {
            break;
        }
        if (TimerGetTicks64() > timeout) {
            break;
        }
    }
}

/**
 * @brief Begins message.
 * @param message Message.
 */
void I2C5BeginMessage(I2CMessage * const message_) {

    // Do nothing if message in progress
    if (I2C5MessageInProgress()) {
        return;
    }

    // Set message
    message = message_;
    message_->index = 0;

    // Calculate message timeout
    timeout = TimerGetTicks64() + (I2C_MESSAGE_MAX_LENGTH * I2C_TIMEOUT);

    // Trigger first interrupt
    EVIC_SourceStatusSet(INT_SOURCE_I2C5_MASTER);
    EVIC_SourceEnable(INT_SOURCE_I2C5_MASTER);
}

/**
 * @brief Returns true if the message is in progress.
 * @return True if the message is in progress.
 */
bool I2C5MessageInProgress(void) {
    if (TimerGetTicks64() >= timeout) {
        EVIC_SourceDisable(INT_SOURCE_I2C5_MASTER);
    }
    return EVIC_SourceIsEnabled(INT_SOURCE_I2C5_MASTER);
}

/**
 * @brief I2C interrupt handler. This function should be called by the ISR
 * implementation generated by MPLAB Harmony.
 */
void I2C5InterruptHandler(void) {
    EVIC_SourceStatusClear(INT_SOURCE_I2C5_MASTER); // clear interrupt flag first because next event may complete before ISR returns
    const int index = message->index++;
    switch (message->event[index]) {
        case I2CMessageEventStart:
            I2C5CONbits.SEN = 1;
            break;
        case I2CMessageEventRepeatedStart:
            I2C5CONbits.RSEN = 1;
            break;
        case I2CMessageEventStop:
            I2C5CONbits.PEN = 1;
            break;
        case I2CMessageEventSend:
            I2C5TRN = message->data[index];
            break;
        case I2CMessageEventReceive:
            I2C5CONbits.RCEN = 1;
            break;
        case I2CMessageEventAck:
            *message->destination[index] = I2C5RCV;
            I2C5CONbits.ACKDT = 0;
            I2C5CONbits.ACKEN = 1;
            break;
        case I2CMessageEventNack:
            *message->destination[index] = I2C5RCV;
            I2C5CONbits.ACKDT = 1;
            I2C5CONbits.ACKEN = 1;
            break;
        case I2CMessageEventEnd:
            EVIC_SourceDisable(INT_SOURCE_I2C5_MASTER);
            if (message->complete != NULL) {
                message->complete();
            }
            break;
    }
}

//------------------------------------------------------------------------------
// End of file
