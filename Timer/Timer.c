/**
 * @file Timer.c
 * @author Seb Madgwick
 * @brief Timer driver for PIC32 devices.
 */

//------------------------------------------------------------------------------
// Includes

#include "definitions.h"
#include "Timer.h"

//------------------------------------------------------------------------------
// Variables

static uint32_t overflowCounter;

//------------------------------------------------------------------------------
// Functions

/**
 * @brief Initialises the module.
 */
void TimerInitialise(void) {

    // Ensure default register states
    TimerDeinitialise();

    // Configure timer
#if defined __PIC32MM__
    CCP1CON1bits.T32 = 1;
    CCP1CON1bits.ON = 1;
#else
    T4CONbits.T32 = 1;
    T4CONbits.ON = 1;
#endif

    // Configure interrupt
#if defined __PIC32MM__
    EVIC_SourceStatusClear(INT_SOURCE_CCT1);
    EVIC_SourceEnable(INT_SOURCE_CCT1);
#else
    EVIC_SourceStatusClear(INT_SOURCE_TIMER_5);
    EVIC_SourceEnable(INT_SOURCE_TIMER_5);
#endif
}

/**
 * @brief Deinitialises the module.
 */
void TimerDeinitialise(void) {

    // Disable timer and restore default register states
#if defined __PIC32MM__
    CCP1CON1 = 0;
#else
    T4CON = 0;
    T5CON = 0;
#endif

    // Disable interrupt
#if defined __PIC32MM__
    EVIC_SourceDisable(INT_SOURCE_CCT1);
#else
    EVIC_SourceDisable(INT_SOURCE_TIMER_5);
#endif
}

/**
 * @brief Gets the 32-bit timer value.
 * @return 32-bit timer value.
 */
uint32_t TimerGetTicks32(void) {
#if defined __PIC32MM__
    return CCP1TMR;
#else
    return TMR4; // read TMR4 and TMR5 as 32-bit timer
#endif
}

/**
 * @brief Gets the 64-bit timer value.
 * @return 64-bit timer value.
 */
uint64_t TimerGetTicks64(void) {

    typedef union {
        uint64_t value;

        struct {
            uint32_t dword0; // least-significant dword
            uint32_t dword1; // most-significant dword
        };
    } Uint64Union;

    Uint64Union uint64Union;
    do {
        uint64Union.dword1 = overflowCounter; // must read this value first
#if defined __PIC32MM__
        uint64Union.dword0 = CCP1TMR; // read 32-bit timer value
#else
        uint64Union.dword0 = TMR4; // read 32-bit timer value
#endif
    } while (uint64Union.dword1 != overflowCounter); // avoid seconds overflow hazard
    return uint64Union.value;
}

/**
 * @brief Blocking delay in milliseconds.
 * @param milliseconds Milliseconds.
 */
void TimerDelayMilliseconds(const uint32_t milliseconds) {
    const uint64_t endTicks = TimerGetTicks64() + ((uint64_t) milliseconds * (uint64_t) TIMER_TICKS_PER_MILLISECOND);
    while (TimerGetTicks64() < endTicks);
}

/**
 * @brief Blocking delay in microseconds. This function should not be used for
 * delays approaching 2^32 microseconds.
 * @param microseconds Microseconds.
 */
void TimerDelayMicroseconds(const uint32_t microseconds) {
    const uint32_t startTicks = TimerGetTicks32();
    while ((TimerGetTicks32() - startTicks) < (microseconds * TIMER_TICKS_PER_MICROSECOND));
}

#if defined __PIC32MM__

/**
 * @brief CCT interrupt handler. This function should be called by the ISR
 * implementation generated by MPLAB Harmony.
 */
void Cct1InterruptHandler(void) {
    overflowCounter++;
    EVIC_SourceStatusClear(INT_SOURCE_CCT1);
}

#else

/**
 * @brief Timer interrupt handler. This function should be called by the ISR
 * implementation generated by MPLAB Harmony.
 */
void Timer5InterruptHandler(void) {
    overflowCounter++;
    EVIC_SourceStatusClear(INT_SOURCE_TIMER_5);
}

#endif

//------------------------------------------------------------------------------
// End of file
