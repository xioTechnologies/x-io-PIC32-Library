/**
 * @file Timer.c
 * @author Seb Madgwick
 * @brief Timer driver for PIC32 devices.
 */

//------------------------------------------------------------------------------
// Includes

#include "definitions.h"
#include "Timer.h"

//------------------------------------------------------------------------------
// Variables

static volatile uint32_t overflowCounter;

//------------------------------------------------------------------------------
// Functions

/**
 * @brief Initialises the module.
 */
void TimerInitialise(void) {

    // Ensure default register states
    TimerDeinitialise();

    // Configure timer
#ifdef __PIC32MM__
    CCP1CON1bits.T32 = 1;
    CCP1CON1bits.ON = 1;
#else
    T2CONbits.T32 = 1;
    T2CONbits.ON = 1;
#endif

    // Enable interrupt
#ifdef __PIC32MM__
    EVIC_SourceEnable(INT_SOURCE_CCT1);
#else
    EVIC_SourceEnable(INT_SOURCE_TIMER_3);
#endif
}

/**
 * @brief Deinitialises the module.
 */
void TimerDeinitialise(void) {
#ifdef __PIC32MM__
    CCP1CON1 = 0;
    CCP1TMR = 0;
    EVIC_SourceDisable(INT_SOURCE_CCT1);
#else
    T2CON = 0;
    T3CON = 0;
    TMR2 = 0;
    EVIC_SourceDisable(INT_SOURCE_TIMER_3);
#endif
    overflowCounter = 0;
}

/**
 * @brief Gets the 32-bit timer value.
 * @return 32-bit timer value.
 */
uint32_t TimerGetTicks32(void) {
#ifdef __PIC32MM__
    return CCP1TMR;
#else
    return TMR2; // read TMR2 and TMR3 as 32-bit timer
#endif
}

/**
 * @brief Gets the 64-bit timer value.
 * @return 64-bit timer value.
 */
uint64_t TimerGetTicks64(void) {
    uint32_t dword1;
    uint32_t dword0;
    do {
        dword1 = overflowCounter; // this value must be read first
#ifdef __PIC32MM__
        dword0 = CCP1TMR; // read 32-bit timer value
#else
        dword0 = TMR2; // read 32-bit timer value
#endif
    } while (dword1 != overflowCounter); // avoid seconds overflow hazard
    return ((uint64_t) dword1 << 32) | (uint64_t) dword0;
}

/**
 * @brief Blocking delay in milliseconds.
 * @param milliseconds Milliseconds.
 */
void TimerDelayMilliseconds(const uint32_t milliseconds) {
    const uint64_t timeout = TimerGetTicks64() + ((uint64_t) milliseconds * (uint64_t) TIMER_TICKS_PER_MILLISECOND);
    while (TimerGetTicks64() < timeout);
}

/**
 * @brief Blocking delay in microseconds. This function should not be used for
 * delays approaching 2^32 microseconds.
 * @param microseconds Microseconds.
 */
void TimerDelayMicroseconds(const uint32_t microseconds) {
    const uint32_t ticks = microseconds * TIMER_TICKS_PER_MICROSECOND;
    const uint32_t start = TimerGetTicks32();
    while ((TimerGetTicks32() - start) < ticks);
}

#ifdef __PIC32MM__

/**
 * @brief CCT interrupt handler. This function should be called by the ISR
 * implementation generated by MPLAB Harmony.
 */
void Cct1InterruptHandler(void) {
    overflowCounter++;
    EVIC_SourceStatusClear(INT_SOURCE_CCT1);
}

#else

/**
 * @brief Timer interrupt handler. This function should be called by the ISR
 * implementation generated by MPLAB Harmony.
 */
void Timer3InterruptHandler(void) {
    overflowCounter++;
    EVIC_SourceStatusClear(INT_SOURCE_TIMER_3);
}

#endif

//------------------------------------------------------------------------------
// End of file
